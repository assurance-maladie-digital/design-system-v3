import { Meta, Source } from '@storybook/addon-docs/blocks';
import '../styles/shared.css';

<Meta title="Guide Du Dev/Guide Technique - Syst√®me de Validation & R√®gles"/>


<div className="header">
  <h1>Guide Technique</h1>
  <h2>Syst√®me de Validation & R√®gles</h2>
  <p>Ce guide technique explique le fonctionnement interne du syst√®me de validation, la cr√©ation de r√®gles personnalis√©es et les cas d'usage avanc√©s.</p>
  
  <div className="guide-links">
    <p>üìñ <strong>Guides compl√©mentaires :</strong></p>
    <ul>
      <li><a href="?path=/docs/guide-du-dev-guide-des-formulaires-syform-validation-automatique--docs">Guide des Formulaires - SyForm & Validation Automatique</a> (approche recommand√©e)</li>
    </ul>
  </div>
</div>

## Architecture du syst√®me

Le syst√®me de validation repose sur deux composables principaux :

### `useFieldValidation`
- **R√¥le** : G√©n√®re et ex√©cute les r√®gles de validation
- **Usage** : Cr√©ation de r√®gles personnalis√©es, validation de champs individuels
- **Retour** : Fonctions de validation pr√™tes √† l'emploi

### `useValidation` 
- **R√¥le** : G√®re l'√©tat de validation et l'affichage des messages
- **Usage** : Int√©gration dans les composants, gestion des √©tats d'erreur/warning/succ√®s
- **Retour** : √âtat r√©actif et m√©thodes de validation

### Priorit√© des validations

Le syst√®me suit une hi√©rarchie stricte :
1. **Erreurs** üî¥ ‚Üí Bloquent la soumission, priorit√© absolue
2. **Avertissements** üü† ‚Üí Informent sans bloquer, priorit√© moyenne  
3. **Succ√®s** üü¢ ‚Üí Encouragent l'utilisateur, priorit√© faible

> **Note** : Cette hi√©rarchie est automatiquement g√©r√©e par `useValidation`

## Structure des types

### Type `ValidationOptions`

Options de configuration pour la validation :

<Source dark code={`
interface ValidationOptions {
  showSuccessMessages?: boolean;  // Activer/d√©sactiver les messages de succ√®s
  fieldIdentifier?: string;       // Nom du champ pour les messages
  customRules?: ValidationRule[]; // R√®gles personnalis√©es
  warningRules?: ValidationRule[]; // R√®gles d'avertissement
  successRules?: ValidationRule[]; // R√®gles de succ√®s
  disableErrorHandling?: boolean; // D√©sactiver compl√®tement la gestion des erreurs
}
`}/>

### Type `ValidationRule`

Structure d'une r√®gle de validation :

<Source dark code={`
type ValidationRule = {
  type: string;     // Type de r√®gle (ex: 'required', 'email')
  options: RuleOptions;
}
`}/>

### Type `RuleOptions`

Options disponibles pour configurer une r√®gle :

<Source dark code={`
interface RuleOptions {
  message?: string;         // Message d'erreur personnalis√©
  successMessage?: string;  // Message de succ√®s personnalis√©
  warningMessage?: string;  // Message d'avertissement personnalis√©
  fieldName?: string;      // Nom du champ pour les messages
  fieldIdentifier?: string; // Identifiant du champ
  value?: any;             // Valeur pour les r√®gles min/max
  length?: number;         // Longueur pour minLength/maxLength
  pattern?: RegExp;        // Expression r√©guli√®re
  ignoreSpace?: boolean;   // Ignorer les espaces
  isWarning?: boolean;     // Traiter comme un avertissement
  validate?: (value: any) => boolean | string; // Validation personnalis√©e
  date?: string | Date;    // Date de r√©f√©rence pour les r√®gles de dates
}
`}/>

## Validation manuelle avec useValidation

Quand SyForm ne suffit pas (composants tiers, logique complexe), utilisez directement `useValidation` :

<Source dark code={`
<script lang="ts" setup>
import { ref } from 'vue'
import { useValidation } from '@cnamts/synapse'

const password = ref('')

const { validateField, hasError, hasWarning, hasSuccess, errors, warnings, successes } = useValidation({
  fieldIdentifier: 'Mot de passe',
  showSuccessMessages: true
})

// R√®gles d'erreur (bloquantes)
const errorRules = [
  { 
    type: 'required',
    options: { message: 'Le mot de passe est requis' }
  },
  { 
    type: 'minLength',
    options: { length: 6, message: 'Le mot de passe doit contenir au moins 6 caract√®res' }
  }
]

// R√®gles d'avertissement (non-bloquantes)
const warningRules = [
  {
    type: 'minLength',
    options: { 
      length: 8,
      warningMessage: 'Un mot de passe de 8 caract√®res minimum est recommand√©'
    }
  }
]

// R√®gles de succ√®s (messages positifs)
const successRules = [
  {
    type: 'minLength',
    options: { 
      length: 12,
      successMessage: 'Excellent ! Votre mot de passe est tr√®s s√©curis√©'
    }
  }
]

const validate = () => {
  const result = validateField(
    password.value,
    errorRules,
    warningRules,
    successRules
  )
  
  // result contient :
  // - hasError: boolean
  // - hasWarning: boolean
  // - hasSuccess: boolean
  // - state: { errors, warnings, successes }
}
</script>

<template>
  <div>
    <input 
      v-model="password"
      @input="validate"
      :class="{ 
        'error': hasError,
        'warning': hasWarning && !hasError,
        'success': hasSuccess
      }"
    />
    
    <!-- Affichage des messages -->
    <div v-if="hasError" class="error-messages">
      <p v-for="error in errors" :key="error">{{ error }}</p>
    </div>
    
    <div v-else-if="hasWarning" class="warning-messages">
      <p v-for="warning in warnings" :key="warning">{{ warning }}</p>
    </div>
    
    <div v-else-if="hasSuccess" class="success-messages">
      <p v-for="success in successes" :key="success">{{ success }}</p>
    </div>
  </div>
</template>
`}/>

## Cr√©ation de r√®gles personnalis√©es

Pour cr√©er vos propres r√®gles de validation, utilisez le type `custom` :

### R√®gle simple avec validation bool√©enne

<Source dark code={`
const passwordStrengthRule = {
  type: 'custom',
  options: {
    validate: (value: string) => {
      const hasNumber = /\d/.test(value);
      const hasUpper = /[A-Z]/.test(value);
      const hasLower = /[a-z]/.test(value);
      const hasSpecial = /[!@#$%^&*(),.?":{}|<>]/.test(value);
      
      // Retourne true si valide, false sinon
      return hasNumber && hasUpper && hasLower && hasSpecial;
    },
    message: 'Le mot de passe doit contenir au moins un chiffre, une majuscule, une minuscule et un caract√®re sp√©cial',
    successMessage: 'Mot de passe s√©curis√© ‚úì'
  }
};
`}/>

### R√®gle avanc√©e avec message conditionnel

<Source dark code={`
const emailDomainRule = {
  type: 'custom',
  options: {
    validate: (value: string) => {
      if (!value) return true; // Laisser 'required' g√©rer les champs vides
      
      if (!value.includes('@')) {
        return 'Format d\'email invalide';
      }
      
      const [localPart, domain] = value.split('@');
      
      if (!domain) {
        return 'Domaine manquant dans l\'email';
      }
      
      if (!domain.endsWith('.fr')) {
        return 'Seuls les domaines .fr sont autoris√©s';
      }
      
      if (domain === 'ameli.fr' && !/^[a-z]+\.[a-z]+$/.test(localPart)) {
        return 'Format ameli.fr requis : prenom.nom@ameli.fr';
      }
      
      return true; // Validation r√©ussie
    },
    fieldIdentifier: 'Email professionnel'
  }
};
`}/>

### R√®gle avec √©tat externe et r√©activit√©

<Source dark code={`
// R√®gle qui d√©pend d'un √©tat externe (ex: liste d'utilisateurs existants)
const userList = ref(['jean.dupont', 'marie.martin', 'pierre.durand']);

const uniqueUsernameRule = computed(() => ({
  type: 'custom',
  options: {
    validate: (value: string) => {
      if (!value) return true;
      
      const normalizedValue = value.toLowerCase().trim();
      
      if (userList.value.includes(normalizedValue)) {
        return 'Ce nom d\'utilisateur est d√©j√† pris';
      }
      
      return true;
    },
    message: 'Nom d\'utilisateur indisponible',
    successMessage: 'Nom d\'utilisateur disponible ‚úì'
  }
}));

// Usage avec computed pour la r√©activit√©
const usernameRules = computed(() => [
  { type: 'required', options: { message: 'Nom d\'utilisateur requis' } },
  { type: 'minLength', options: { length: 3, message: 'Minimum 3 caract√®res' } },
  uniqueUsernameRule.value // R√®gle r√©active
]);
`}/>

### R√®gles asynchrones (validation serveur)

<Source dark code={`
const asyncEmailRule = {
  type: 'custom',
  options: {
    validate: async (value: string) => {
      if (!value || !value.includes('@')) return true;
      
      try {
        // Simulation d'un appel API
        const response = await fetch(\`/api/check-email?email=\${encodeURIComponent(value)}\`);
        const result = await response.json();
        
        if (!result.available) {
          return 'Cette adresse email est d√©j√† utilis√©e';
        }
        
        return true;
      } catch (error) {
        // En cas d'erreur r√©seau, on ne bloque pas
        console.warn('Impossible de v√©rifier l\'email:', error);
        return true;
      }
    },
    message: 'Email d√©j√† utilis√©',
    successMessage: 'Email disponible'
  }
};
`}/>

## R√®gles de validation disponibles

### R√®gles basiques
- `required` : V√©rifie qu'une valeur est pr√©sente
- `min` : V√©rifie qu'une valeur num√©rique est sup√©rieure ou √©gale √† un minimum
- `max` : V√©rifie qu'une valeur num√©rique est inf√©rieure ou √©gale √† un maximum
- `minLength` : V√©rifie qu'une cha√Æne a une longueur minimale
- `maxLength` : V√©rifie qu'une cha√Æne a une longueur maximale
- `exactLength` : V√©rifie qu'une cha√Æne a une longueur exacte
- `email` : V√©rifie qu'une cha√Æne est un email valide
- `matchPattern` : V√©rifie qu'une cha√Æne correspond √† une expression r√©guli√®re

### R√®gles de validation de dates
- `notWeekend` : V√©rifie qu'une date n'est pas un jour de week-end
- `notBeforeToday` : V√©rifie qu'une date n'est pas ant√©rieure √† aujourd'hui
- `notAfterToday` : V√©rifie qu'une date n'est pas post√©rieure √† aujourd'hui
- `notBeforeDate` : V√©rifie qu'une date n'est pas ant√©rieure √† une date de r√©f√©rence
- `notAfterDate` : V√©rifie qu'une date n'est pas post√©rieure √† une date de r√©f√©rence
- `dateExact` : V√©rifie qu'une date est exactement √©gale √† une date de r√©f√©rence

### R√®gle personnalis√©e
- `custom` : Permet de d√©finir une validation personnalis√©e via la fonction `validate`

## M√©thodes disponibles

Le composable `useValidation` retourne plusieurs m√©thodes utiles :

- `validateField` : Valide une valeur selon les r√®gles d√©finies
- `validateOnSubmit` : V√©rifie si le formulaire peut √™tre soumis (retourne `true` si aucune erreur)
- `clearValidation` : R√©initialise l'√©tat de validation (efface erreurs, avertissements et succ√®s)

## Bonnes pratiques

1. **Messages clairs** : Utilisez des messages explicites qui guident l'utilisateur
2. **Validation progressive** : Validez au fur et √† mesure de la saisie
3. **Avertissements utiles** : Utilisez les warnings pour des recommandations non-bloquantes
4. **Messages de succ√®s** : Encouragez les bonnes pratiques avec des messages positifs
5. **Identifiants de champs** : Utilisez `fieldIdentifier` pour des messages contextuels

> **‚ö†Ô∏è Important ‚Äî Ordre des r√®gles :** placez toujours `required` en dernier dans la liste de vos r√®gles !
> Les r√®gles sont √©valu√©es dans l'ordre de leur d√©claration, et la validation s'arr√™te d√®s qu'une erreur est rencontr√©e.
> Si `required` est positionn√© en premier et que l'utilisateur saisit une valeur (m√™me invalide), la validation s'arr√™tera imm√©diatement.
> En revanche, en le pla√ßant en dernier, si une autre r√®gle √©choue avant, l'utilisateur obtiendra le message d'erreur le plus pertinent.

## Exemple de validation personnalis√©e

<Source dark code={`
const customRules = [
  {
    type: 'custom',
    options: {
      validate: (value: string) => {
        const hasNumber = /\d/.test(value)
        const hasUpper = /[A-Z]/.test(value)
        const hasLower = /[a-z]/.test(value)
        
        if (!hasNumber || !hasUpper || !hasLower) {
          return 'Le mot de passe doit contenir au moins un chiffre, une majuscule et une minuscule'
        }
        
        return true
      },
      successMessage: 'Votre mot de passe respecte les crit√®res de s√©curit√©'
    }
  }
]
`}/>

## Conclusion

Le syst√®me de validation du Design System offre une grande flexibilit√© tout en restant simple √† utiliser. La combinaison des erreurs, avertissements et succ√®s permet de cr√©er une exp√©rience utilisateur riche et intuitive.
