import { Meta, Source } from '@storybook/addon-docs/blocks';
import '../styles/shared.css';

<Meta title="Guide Du Dev/Utiliser le syst√®me de validation"/>


<div className="header">
  <h1>Utiliser le syst√®me de validation</h1>
  <p>Ce guide d√©crit comment utiliser le syst√®me de validation de formulaires du Design System pour cr√©er des validations flexibles et intuitives. </p>
</div>

## Introduction

Le syst√®me de validation repose sur deux composables principaux :
- `useFieldValidation` : G√®re la cr√©ation des r√®gles de validation
- `useValidation` : G√®re l'√©tat de validation et l'affichage des messages

## Les 3 types de validation

Notre syst√®me supporte trois types de retours de validation :

1. **Erreurs** (rouge üî¥) : Bloquent la soumission du formulaire
2. **Avertissements** (orange üü†) : Informent l'utilisateur sans bloquer
3. **Succ√®s** (vert üü¢) : Confirment la validit√© du champ

### Priorit√© des validations

Les validations suivent un ordre de priorit√© :
1. Si une erreur est pr√©sente, elle est affich√©e en priorit√©
2. S'il n'y a pas d'erreur mais des avertissements, ils sont affich√©s
3. S'il n'y a ni erreur ni avertissement, les messages de succ√®s sont affich√©s

## Structure des types

### Type `ValidationOptions`

Options de configuration pour la validation :

<Source dark code={`
interface ValidationOptions {
  showSuccessMessages?: boolean;  // Activer/d√©sactiver les messages de succ√®s
  fieldIdentifier?: string;       // Nom du champ pour les messages
  customRules?: ValidationRule[]; // R√®gles personnalis√©es
  warningRules?: ValidationRule[]; // R√®gles d'avertissement
  successRules?: ValidationRule[]; // R√®gles de succ√®s
  disableErrorHandling?: boolean; // D√©sactiver compl√®tement la gestion des erreurs
}
`}/>

### Type `ValidationRule`

Structure d'une r√®gle de validation :

<Source dark code={`
type ValidationRule = {
  type: string;     // Type de r√®gle (ex: 'required', 'email')
  options: RuleOptions;
}
`}/>

### Type `RuleOptions`

Options disponibles pour configurer une r√®gle :

<Source dark code={`
interface RuleOptions {
  message?: string;         // Message d'erreur personnalis√©
  successMessage?: string;  // Message de succ√®s personnalis√©
  warningMessage?: string;  // Message d'avertissement personnalis√©
  fieldName?: string;      // Nom du champ pour les messages
  fieldIdentifier?: string; // Identifiant du champ
  value?: any;             // Valeur pour les r√®gles min/max
  length?: number;         // Longueur pour minLength/maxLength
  pattern?: RegExp;        // Expression r√©guli√®re
  ignoreSpace?: boolean;   // Ignorer les espaces
  isWarning?: boolean;     // Traiter comme un avertissement
  validate?: (value: any) => boolean | string; // Validation personnalis√©e
  date?: string | Date;    // Date de r√©f√©rence pour les r√®gles de dates
}
`}/>

## Exemple complet d'utilisation

### Avec un input simple

Voici un exemple complet montrant les diff√©rentes possibilit√©s de validation :

<Source dark code={`
<script lang="ts" setup>
import { ref } from 'vue'
import { useValidation } from '@cnamts/synapse'

const password = ref('')

const { validateField, hasError, hasWarning, hasSuccess, errors, warnings, successes } = useValidation({
  fieldIdentifier: 'Mot de passe',
  showSuccessMessages: true
})

// R√®gles d'erreur (bloquantes)
const errorRules = [
  { 
    type: 'required',
    options: { message: 'Le mot de passe est requis' }
  },
  { 
    type: 'minLength',
    options: { length: 6, message: 'Le mot de passe doit contenir au moins 6 caract√®res' }
  }
]

// R√®gles d'avertissement (non-bloquantes)
const warningRules = [
  {
    type: 'minLength',
    options: { 
      length: 8,
      warningMessage: 'Un mot de passe de 8 caract√®res minimum est recommand√©'
    }
  }
]

// R√®gles de succ√®s (messages positifs)
const successRules = [
  {
    type: 'minLength',
    options: { 
      length: 12,
      successMessage: 'Excellent ! Votre mot de passe est tr√®s s√©curis√©'
    }
  }
]

const validate = () => {
  const result = validateField(
    password.value,
    errorRules,
    warningRules,
    successRules
  )
  
  // result contient :
  // - hasError: boolean
  // - hasWarning: boolean
  // - hasSuccess: boolean
  // - state: { errors, warnings, successes }
}
</script>

<template>
  <div>
    <input 
      v-model="password"
      @input="validate"
      :class="{ 
        'error': hasError,
        'warning': hasWarning && !hasError,
        'success': hasSuccess
      }"
    />
    
    <!-- Affichage des messages -->
    <div v-if="hasError" class="error-messages">
      <p v-for="error in errors" :key="error">{{ error }}</p>
    </div>
    
    <div v-else-if="hasWarning" class="warning-messages">
      <p v-for="warning in warnings" :key="warning">{{ warning }}</p>
    </div>
    
    <div v-else-if="hasSuccess" class="success-messages">
      <p v-for="success in successes" :key="success">{{ success }}</p>
    </div>
  </div>
</template>
`}/>

### Avec SyTextField

Le `SyTextField` int√®gre nativement notre syst√®me de validation. Voici un exemple complet :

<Source dark code={`
<script lang="ts" setup>
import { ref } from 'vue'
import { SyTextField } from '@cnamts/synapse'

const password = ref('')

// R√®gles d'erreur (bloquantes)
const rules = [
  { 
    type: 'required',
    options: { message: 'Le mot de passe est requis' }
  },
  { 
    type: 'minLength',
    options: { length: 6, message: 'Le mot de passe doit contenir au moins 6 caract√®res' }
  }
]

// R√®gles d'avertissement (non-bloquantes)
const warningRules = [
  {
    type: 'minLength',
    options: { 
      length: 8,
      warningMessage: 'Un mot de passe de 8 caract√®res minimum est recommand√©'
    }
  }
]

// R√®gles de succ√®s (messages positifs)
const successRules = [
  {
    type: 'minLength',
    options: { 
      length: 12,
      successMessage: 'Excellent ! Votre mot de passe est tr√®s s√©curis√©'
    }
  }
]
</script>

<template>
  <SyTextField
    v-model="password"
    label="Mot de passe"
    type="password"
    :customRules="rules"
    :customWarningRules="warningRules"
    :customSuccessRules="successRules"
    placeholder="Entrez votre mot de passe"
  />
</template>
`}/>

Le composant affichera automatiquement :
- Une ic√¥ne et un message d'erreur en rouge si le champ est vide ou contient moins de 6 caract√®res
- Une ic√¥ne et un message d'avertissement en orange si le mot de passe fait entre 6 et 8 caract√®res
- Une ic√¥ne et un message de succ√®s en vert si le mot de passe fait 12 caract√®res ou plus

### Validation personnalis√©e avec SyTextField

Voici un exemple plus avanc√© avec une validation personnalis√©e :

<Source dark code={`
<script lang="ts" setup>
import { ref } from 'vue'
import { SyTextField } from '
import '../styles/shared.css';@cnamts/synapse'

const email = ref('')

// R√®gle personnalis√©e pour v√©rifier le domaine ameli.fr
const rules = [
  { 
    type: 'required',
    options: { message: 'L\'email est requis' }
  },
  { 
    type: 'email',
    options: { message: 'Format d\'email invalide' }
  },
  {
    type: 'custom',
    options: {
      validate: (value: string) => {
        if (!value.endsWith('@ameli.fr')) {
          return 'L\'email doit √™tre un email ameli.fr'
        }
        return true
      }
    }
  }
]

// R√®gle d'avertissement pour le format pr√©nom.nom
const warningRules = [
  {
    type: 'custom',
    options: {
      validate: (value: string) => {
        const [localPart] = value.split('@')
        if (!/^[a-z]+\.[a-z]+$/.test(localPart)) {
          return 'Format recommand√© : prenom.nom@ameli.fr'
        }
        return true
      },
      isWarning: true
    }
  }
]
</script>

<template>
  <SyTextField
    v-model="email"
    label="Email professionnel"
    :customRules="rules"
    :customWarningRules="warningRules"
    placeholder="prenom.nom@ameli.fr"
  />
</template>
`}/>

Dans cet exemple :
- Le champ est invalide si l'email n'est pas au format @ameli.fr
- Un avertissement s'affiche si l'email ne suit pas le format prenom.nom
- La validation se fait automatiquement √† la perte du focus
- Les ic√¥nes et couleurs sont g√©r√©es automatiquement par le composant

## R√®gles de validation disponibles

### R√®gles basiques
- `required` : V√©rifie qu'une valeur est pr√©sente
- `min` : V√©rifie qu'une valeur num√©rique est sup√©rieure ou √©gale √† un minimum
- `max` : V√©rifie qu'une valeur num√©rique est inf√©rieure ou √©gale √† un maximum
- `minLength` : V√©rifie qu'une cha√Æne a une longueur minimale
- `maxLength` : V√©rifie qu'une cha√Æne a une longueur maximale
- `exactLength` : V√©rifie qu'une cha√Æne a une longueur exacte
- `email` : V√©rifie qu'une cha√Æne est un email valide
- `matchPattern` : V√©rifie qu'une cha√Æne correspond √† une expression r√©guli√®re

### R√®gles de validation de dates
- `notWeekend` : V√©rifie qu'une date n'est pas un jour de week-end
- `notBeforeToday` : V√©rifie qu'une date n'est pas ant√©rieure √† aujourd'hui
- `notAfterToday` : V√©rifie qu'une date n'est pas post√©rieure √† aujourd'hui
- `notBeforeDate` : V√©rifie qu'une date n'est pas ant√©rieure √† une date de r√©f√©rence
- `notAfterDate` : V√©rifie qu'une date n'est pas post√©rieure √† une date de r√©f√©rence
- `dateExact` : V√©rifie qu'une date est exactement √©gale √† une date de r√©f√©rence

### R√®gle personnalis√©e
- `custom` : Permet de d√©finir une validation personnalis√©e via la fonction `validate`

## M√©thodes disponibles

Le composable `useValidation` retourne plusieurs m√©thodes utiles :

- `validateField` : Valide une valeur selon les r√®gles d√©finies
- `validateOnSubmit` : V√©rifie si le formulaire peut √™tre soumis (retourne `true` si aucune erreur)
- `clearValidation` : R√©initialise l'√©tat de validation (efface erreurs, avertissements et succ√®s)

## Bonnes pratiques

1. **Messages clairs** : Utilisez des messages explicites qui guident l'utilisateur
2. **Validation progressive** : Validez au fur et √† mesure de la saisie
3. **Avertissements utiles** : Utilisez les warnings pour des recommandations non-bloquantes
4. **Messages de succ√®s** : Encouragez les bonnes pratiques avec des messages positifs
5. **Identifiants de champs** : Utilisez `fieldIdentifier` pour des messages contextuels

## Exemple de validation personnalis√©e

<Source dark code={`
const customRules = [
  {
    type: 'custom',
    options: {
      validate: (value: string) => {
        const hasNumber = /\d/.test(value)
        const hasUpper = /[A-Z]/.test(value)
        const hasLower = /[a-z]/.test(value)
        
        if (!hasNumber || !hasUpper || !hasLower) {
          return 'Le mot de passe doit contenir au moins un chiffre, une majuscule et une minuscule'
        }
        
        return true
      },
      successMessage: 'Votre mot de passe respecte les crit√®res de s√©curit√©'
    }
  }
]
`}/>

## Conclusion

Le syst√®me de validation du Design System offre une grande flexibilit√© tout en restant simple √† utiliser. La combinaison des erreurs, avertissements et succ√®s permet de cr√©er une exp√©rience utilisateur riche et intuitive.
