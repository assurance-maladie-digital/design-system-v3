import { Meta, Source } from '@storybook/addon-docs/blocks';
import '../styles/shared.css';

<Meta title="Guide Du Dev/Guide de Validation des Formulaires"/>


<div className="header">
  <h1>Guide de Validation des Formulaires</h1>
  <p>Ce guide pratique explique comment utiliser le syst√®me de validation des formulaires du Design System dans vos applications.</p>
</div>

## Les bases de la validation

Le syst√®me de validation offre un m√©canisme complet et intuitif pour valider les entr√©es utilisateur avec trois niveaux de retour :

- **Erreurs** üî¥ : Emp√™chent la soumission du formulaire
- **Avertissements** üü† : Informent l'utilisateur sans bloquer la soumission
- **Succ√®s** üü¢ : Confirment la validit√© de l'entr√©e

## Mise en place simple

Voici comment mettre en place une validation basique sur un champ :

<Source dark code={`
<template>
  <SyTextField
    v-model="email"
    label="Email"
    :custom-rules="emailRules"
  />
</template>

<script setup>
import { ref } from 'vue';
import { SyTextField } from '@cnamts/synapse';

const email = ref('');

const emailRules = [
  { 
    type: 'required',
    options: { message: "L'email est obligatoire" }
  },
  { 
    type: 'email',
    options: { message: "L'email n'est pas valide" }
  }
];
</script>
`}/>

## Validation compl√®te avec les 3 niveaux

Utilisez les diff√©rents types de r√®gles pour une exp√©rience utilisateur riche :

<Source dark code={`
<script setup>
	import { ref } from 'vue'
	import PasswordField from '@/components/PasswordField/PasswordField.vue'

	const password = ref('')

	// R√®gles d'erreur (bloquantes)
	const passwordRules = [
		{
			type: 'required',
			options: { 
        message: 'Le mot de passe est obligatoire',
      },
		},
		{
			type: 'minLength',
			options: { 
        length: 8, 
        message: 'Le mot de passe doit contenir au moins 8 caract√®res',
      // si pas de successMessage, le message par defaut est affich√©
        successMessage: 'Le mot de passe est s√©curis√©',
         },
		},
	]

	// R√®gles d'avertissement (non-bloquantes)
	const passwordWarningRules = [
		{
			type: 'custom',
			options: {
				validate: (value) => {
					const hasSpecialChar = /[!@#$%^&*(),.?":{}|<>]/.test(value)
					if (!hasSpecialChar) {
						return 'Le mot de passe pourrait √™tre plus fort avec des caract√®res sp√©ciaux'
					}
					return true
				},
				fieldIdentifier: 'password',
			},
		},
	]

  </script>

<template>
	<PasswordField
		v-model="password"
		label="Mot de passe"
		:custom-warning-rules="passwordWarningRules"
		:custom-rules="passwordRules"
	/>
</template>

`}/>

## Validation √† la soumission avec validateOnSubmit

La m√©thode `validateOnSubmit` est essentielle pour valider l'ensemble du formulaire lors de sa soumission :

<Source dark code={`
<template>
  <form @submit.prevent="handleSubmit">
    <SyTextField
      ref="emailField"
      v-model="email"
      label="Email"
      :custom-rules="emailRules"
    />
    
    <PasswordField
      ref="passwordField"
      v-model="password"
      label="Mot de passe"
      type="password"
      :custom-rules="passwordRules"
    />
    
    <VBtn type="submit">Se connecter</VBtn>
    
    <p v-if="formError" class="error-message">{{ formError }}</p>
  </form>
</template>

<script setup>
import { ref } from 'vue';
import { SyTextField, PasswordField } from '@cnamts/synapse';

const email = ref('');
const password = ref('');
const formError = ref('');

const emailField = ref();
const passwordField = ref();

const emailRules = [
  { type: 'required', options: { message: "L'email est obligatoire" } },
  { type: 'email', options: { message: "L'email n'est pas valide" } }
];

const passwordRules = [
  { type: 'required', options: { message: 'Le mot de passe est obligatoire' } }
];

const handleSubmit = async () => {
  formError.value = '';
  
  // Validation de tous les champs
  const isEmailValid = await emailField.value.validateOnSubmit();
  const isPasswordValid = await passwordField.value.validateOnSubmit();
  
  if (isEmailValid && isPasswordValid) {
    // Soumettre le formulaire
    console.log('Formulaire soumis avec succ√®s !');
    // loginUser(email.value, password.value);
  } else {
    formError.value = 'Veuillez corriger les erreurs dans le formulaire';
  }
};
</script>
`}/>

## Validation crois√©e entre champs

Parfois, la validation d'un champ d√©pend de la valeur d'un autre champ. Voici comment g√©rer ce cas :

<Source dark code={`
<template>
  <form @submit.prevent="handleSubmit">
    <PasswordField
      ref="passwordField"
      v-model="password"
      label="Mot de passe"
      type="password"
      :custom-rules="passwordRules"
    />
    
    <PasswordField
      ref="confirmPasswordField"
      v-model="confirmPassword"
      label="Confirmer le mot de passe"
      type="password"
      :custom-rules="confirmPasswordRules"
    />
    
    <VBtn type="submit">S'inscrire</VBtn>
  </form>
</template>

<script setup>
import { ref, watch } from 'vue';
import { PasswordField } from '@cnamts/synapse';

const password = ref('');
const confirmPassword = ref('');

const passwordField = ref();
const confirmPasswordField = ref();

const passwordRules = [
  { type: 'required', options: { message: 'Le mot de passe est obligatoire' } },
  { type: 'minLength', options: { length: 8, message: 'Le mot de passe doit contenir au moins 8 caract√®res' } }
];

const confirmPasswordRules = [
  { type: 'required', options: { message: 'La confirmation du mot de passe est obligatoire' } },
  {
    type: 'custom',
    options: {
      validate: (value) => {
        if (value !== password.value) {
          return 'Les mots de passe ne correspondent pas';
        }
        return true;
      }
    }
  }
];

// Revalider la confirmation lorsque le mot de passe change
watch(password, () => {
  if (confirmPassword.value && confirmPasswordField.value) {
    // Forcer la validation du champ de confirmation
    confirmPasswordField.value.validateOnSubmit();
  }
});

const handleSubmit = async () => {
  // Validation de tous les champs
  const isPasswordValid = await passwordField.value.validateOnSubmit();
  const isConfirmValid = await confirmPasswordField.value.validateOnSubmit();
  
  if (isPasswordValid && isConfirmValid) {
    // Soumettre le formulaire
    console.log('Inscription r√©ussie !');
  }
};
</script>
`}/>

## Composants avec validation int√©gr√©e

Plusieurs composants du Design System int√®grent d√©j√† la validation :

- **SyTextField** : Pour les champs texte
- **NirField** : Pour les num√©ros de s√©curit√© sociale
- **DatePicker** : Pour les dates
- **PeriodField** : Pour les p√©riodes (deux dates li√©es)
- **PasswordField** : Pour les mots de passe s√©curis√©s

### Exemple avec NirField

<Source dark code={`
<template>
  <form @submit.prevent="handleSubmit">
    <NirField
      ref="nirFieldRef"
      v-model="nirValue"
      label="Num√©ro de s√©curit√© sociale"
    />
    
    <SyButton type="submit">Valider</SyButton>
  </form>
</template>

<script setup>
import { ref } from 'vue';
import { NirField, SyButton } from '
import '../styles/shared.css';@cnamts/synapse';

const nirValue = ref('');
const nirFieldRef = ref();

const handleSubmit = async () => {
  const isValid = await nirFieldRef.value.validateOnSubmit();
  
  if (isValid) {
    console.log('NIR valide :', nirValue.value);
  }
};
</script>
`}/>

## R√®gles de validation disponibles

### R√®gles g√©n√©riques
- `required` : Champ obligatoire
- `minLength` / `maxLength` : Longueur minimale/maximale
- `min` / `max` : Valeur minimale/maximale pour les nombres
- `email` : Format d'email valide
- `matchPattern` : Correspondance √† une expression r√©guli√®re

### R√®gles de dates
- `notBeforeToday` / `notAfterToday` : Date apr√®s/avant aujourd'hui
- `notBeforeDate` / `notAfterDate` : Date apr√®s/avant une date sp√©cifique
- `notWeekend` : Jour ouvrable
- `isHolidayDay` : Jour non f√©ri√©

### R√®gles personnalis√©es
Utilisez le type `custom` avec une fonction `validate` pour cr√©er vos propres r√®gles :

<Source dark code={`
const customRule = {
  type: 'custom',
  options: {
    validate: (value) => {
      // Votre logique personnalis√©e
      if (!condition) {
        return 'Message d\'erreur personnalis√©';
      }
      return true; // Valide
    },
    // Optionnel : traiter comme avertissement au lieu d'erreur
    isWarning: false
  }
};
`}/>

## Bonnes pratiques

1. **Validation progressive** : Validez pendant la saisie pour une r√©troaction imm√©diate
2. **Messages clairs** : Utilisez des messages d'erreur explicites et constructifs
3. **Validation c√¥t√© client ET serveur** : Ne vous fiez jamais uniquement √† la validation c√¥t√© client
4. **Utilisez validateOnSubmit** : Assurez-vous que tous les champs sont valid√©s √† la soumission
5. **Hi√©rarchisez les erreurs** : Affichez d'abord les erreurs les plus importantes et toujours required en dernier
6. **Utilisez les avertissements** pour les recommandations non-bloquantes
7. **C√©l√©brez la r√©ussite** avec des messages de succ√®s pour renforcer les bonnes pratiques

## Conclusion

Le syst√®me de validation du Design System vous permet de cr√©er des formulaires intuitifs avec des retours utilisateur riches. En combinant validation √† la saisie et validation √† la soumission, vous offrez une exp√©rience utilisateur optimale tout en garantissant l'int√©grit√© des donn√©es.
