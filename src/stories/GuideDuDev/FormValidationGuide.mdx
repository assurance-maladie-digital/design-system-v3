import { Meta, Source } from '@storybook/addon-docs/blocks';
import '../styles/shared.css';

<Meta title="Guide Du Dev/Guide des Formulaires - SyForm & Validation Automatique"/>


<div className="header">
  <h1>Guide des Formulaires</h1>
  <h2>SyForm & Validation Automatique</h2>
  <p>Ce guide pratique vous montre comment cr√©er des formulaires modernes avec SyForm et la validation automatique. <strong>C'est l'approche recommand√©e</strong> pour la plupart des cas d'usage.</p>
  
  <div className="guide-links">
    <p>üìñ <strong>Guides compl√©mentaires :</strong></p>
    <ul>
      <li><a href="?path=/docs/guide-du-dev-guide-technique-syst√®me-de-validation-r√®gles--docs">Guide Technique - Syst√®me de Validation & R√®gles</a> (validation manuelle, r√®gles personnalis√©es)</li>
    </ul>
  </div>
</div>

## Pourquoi SyForm ?

SyForm est la solution moderne du design system pour cr√©er des formulaires avec validation automatique. Il simplifie drastiquement le d√©veloppement en g√©rant automatiquement :

- ‚úÖ **Validation automatique** √† la soumission
- ‚úÖ **Gestion centralis√©e** de tous les champs
- ‚úÖ **Auto-enregistrement** des composants de validation
- ‚úÖ **Compatibilit√©** avec tous les composants du design system
- ‚úÖ **Moins de code** √† √©crire et maintenir

> **Note** : Pour la validation crois√©e, vous devez toujours utiliser `computed()` pour rendre les r√®gles r√©actives, m√™me avec SyForm.

## Les 3 niveaux de validation

Le syst√®me supporte trois types de retours pour une exp√©rience utilisateur riche :

- **Erreurs** üî¥ : Emp√™chent la soumission du formulaire
- **Avertissements** üü† : Informent l'utilisateur sans bloquer la soumission  
- **Succ√®s** üü¢ : Confirment la validit√© de l'entr√©e et encouragent l'utilisateur

## Votre premier formulaire avec SyForm

Commen√ßons par un exemple simple d'un formulaire complet avec validation automatique :

<Source dark code={`
<template>
  <SyForm ref="form" @submit="handleSubmit" :validate-on-submit="true">
    <div class="d-flex flex-column gap-4">
      <SyTextField 
        v-model="email" 
        label="Email" 
        :custom-rules="emailRules" 
      />
      <SyTextField 
        v-model="name" 
        label="Nom complet" 
        required 
      />
      <VBtn type="submit" color="primary">Envoyer</VBtn>
    </div>
  </SyForm>
</template>

<script setup>

const email = ref('');
const name = ref('');
const form = ref();

const emailRules = [
  { type: 'email', options: { message: "L'email n'est pas valide" } },
  { type: 'required', options: { message: "L'email est obligatoire" } }
];

const handleSubmit = async () => {
  // Cette fonction n'est appel√©e QUE si le formulaire est valide !
  console.log('Formulaire valide, envoi en cours...');
  console.log({ email: email.value, name: name.value });
};
</script>
`}/>

### üéØ Points cl√©s de cet exemple

- **`SyForm`** : Conteneur qui g√®re automatiquement la validation
- **`validate-on-submit="true"`** : Valide tous les champs √† la soumission
- **`@submit`** : Ne se d√©clenche QUE si le formulaire est valide
- **`required`** : Validation simple directement sur le composant
- **`:custom-rules`** : R√®gles de validation personnalis√©es

> **‚ö†Ô∏è Important ‚Äî Ordre des r√®gles :** placez toujours `required` en dernier dans la liste de vos r√®gles !
> Les r√®gles sont √©valu√©es dans l'ordre de leur d√©claration, et la validation s'arr√™te d√®s qu'une erreur est rencontr√©e.
> Si `required` est positionn√© en premier et que l'utilisateur saisit une valeur (m√™me invalide), la validation s'arr√™tera imm√©diatement.
> En revanche, en le pla√ßant en dernier, si une autre r√®gle √©choue avant, l'utilisateur obtiendra le message d'erreur le plus pertinent.

## Validation compl√®te avec les 3 niveaux

Voici un exemple complet utilisant erreurs, avertissements et succ√®s dans un formulaire SyForm :

<Source dark code={`
<template>
  <SyForm ref="form" @submit="handleSubmit">
    <div class="d-flex flex-column gap-4">
      <SyTextField
        v-model="password"
        label="Mot de passe"
        type="password"
        :custom-rules="passwordRules"
        :custom-warning-rules="passwordWarningRules"
        :custom-success-rules="passwordSuccessRules"
      />
      <VBtn type="submit" color="primary">Cr√©er le compte</VBtn>
    </div>
  </SyForm>
</template>

<script setup>

const password = ref('');
const form = ref();

// R√®gles d'erreur (bloquantes)
const passwordRules = [
  { type: 'minLength', options: { length: 8, message: 'Minimum 8 caract√®res' } },
  { type: 'required', options: { message: 'Le mot de passe est obligatoire' } }
];

// R√®gles d'avertissement (non-bloquantes)
const passwordWarningRules = [
  {
    type: 'custom',
    options: {
      validate: (value) => {
        const hasSpecialChar = /[!@#$%^&*(),.?":{}|<>]/.test(value);
        if (!hasSpecialChar) {
          return 'Ajoutez des caract√®res sp√©ciaux pour plus de s√©curit√©';
        }
        return true;
      }
    }
  }
];

// R√®gles de succ√®s (encouragement)
const passwordSuccessRules = [
  {
    type: 'custom',
    options: {
      validate: (value) => {
        const hasUpper = /[A-Z]/.test(value);
        const hasLower = /[a-z]/.test(value);
        const hasNumber = /\d/.test(value);
        const hasSpecial = /[!@#$%^&*(),.?":{}|<>]/.test(value);
        
        if (hasUpper && hasLower && hasNumber && hasSpecial && value.length >= 12) {
          return 'Excellent ! Mot de passe tr√®s s√©curis√© üîí';
        }
        return true;
      }
    }
  }
];

const handleSubmit = () => {
  console.log('Compte cr√©√© avec succ√®s !');
};
</script>
`}/>

### üé® R√©sultat visuel

Dans cet exemple, l'utilisateur verra :
- **Erreur rouge** si le mot de passe est vide ou < 8 caract√®res
- **Avertissement orange** si pas de caract√®res sp√©ciaux (mais formulaire soumissible)
- **Succ√®s vert** si le mot de passe est tr√®s s√©curis√© (12+ caract√®res avec tous les types)

## Validation crois√©e entre champs

Pour des validations qui d√©pendent de plusieurs champs (ex: confirmation de mot de passe), utilisez des **r√®gles r√©actives** avec `computed()` :

<Source dark code={`
<template>
  <SyForm ref="form" @submit="handleSubmit">
    <div class="d-flex flex-column gap-4">
      <SyTextField 
        v-model="username" 
        label="Nom d'utilisateur" 
        required 
      />
      <SyTextField 
        v-model="password" 
        label="Mot de passe" 
        type="password" 
        :custom-rules="passwordRules" 
      />
      <SyTextField 
        v-model="confirmPassword" 
        label="Confirmer le mot de passe" 
        type="password" 
        :custom-rules="confirmPasswordRules" 
      />
      <VBtn type="submit" color="primary">S'inscrire</VBtn>
    </div>
  </SyForm>
</template>

<script setup>

const username = ref('');
const password = ref('');
const confirmPassword = ref('');
const form = ref();

// R√®gles r√©actives pour la validation crois√©e
const passwordRules = computed(() => [
  { type: 'minLength', options: { length: 8, message: 'Minimum 8 caract√®res' } },
  { type: 'required', options: { message: 'Le mot de passe est obligatoire' } },
]);

const confirmPasswordRules = computed(() => [
  { 
    type: 'custom', 
    options: {
      validate: value => value === password.value || 'Les mots de passe ne correspondent pas',
      message: 'Les mots de passe ne correspondent pas',
    } 
  },
  { type: 'required', options: { message: 'Veuillez confirmer le mot de passe' } },
]);

const handleSubmit = async () => {
  // SyForm g√®re automatiquement la validation !
  console.log('Inscription r√©ussie !', { username: username.value });
};
</script>
`}/>

### üîë Points cl√©s de la validation crois√©e

- **`computed()` obligatoire** : Les r√®gles se recalculent automatiquement quand `password.value` change
- **R√©activit√© manuelle** : Vous devez explicitement rendre les r√®gles r√©actives avec `computed()`
- **SyForm** : G√®re la validation centralis√©e mais pas la r√©activit√© des r√®gles
- **Avantage vs approche manuelle** : Plus besoin de `watch()` pour revalider les champs

## Formulaires complexes avec SyForm

<Source dark code={`
<template>
  <form @submit.prevent="handleSubmit">
    <PasswordField
      ref="passwordField"
      v-model="password"
      label="Mot de passe"
      type="password"
      :custom-rules="passwordRules"
    />
    
    <PasswordField
      ref="confirmPasswordField"
      v-model="confirmPassword"
      label="Confirmer le mot de passe"
      type="password"
      :custom-rules="confirmPasswordRules"
    />
    
    <VBtn type="submit">S'inscrire</VBtn>
  </form>
</template>

<script setup>

const password = ref('');
const confirmPassword = ref('');

const passwordField = ref();
const confirmPasswordField = ref();

const passwordRules = [
  { type: 'required', options: { message: 'Le mot de passe est obligatoire' } },
  { type: 'minLength', options: { length: 8, message: 'Le mot de passe doit contenir au moins 8 caract√®res' } }
];

const confirmPasswordRules = [
  { type: 'required', options: { message: 'La confirmation du mot de passe est obligatoire' } },
  {
    type: 'custom',
    options: {
      validate: (value) => {
        if (value !== password.value) {
          return 'Les mots de passe ne correspondent pas';
        }
        return true;
      }
    }
  }
];

// Revalider la confirmation lorsque le mot de passe change
watch(password, () => {
  if (confirmPassword.value && confirmPasswordField.value) {
    // Forcer la validation du champ de confirmation
    confirmPasswordField.value.validateOnSubmit();
  }
});

const handleSubmit = async () => {
  // Validation de tous les champs
  const isPasswordValid = await passwordField.value.validateOnSubmit();
  const isConfirmValid = await confirmPasswordField.value.validateOnSubmit();
  
  if (isPasswordValid && isConfirmValid) {
    // Soumettre le formulaire
    console.log('Inscription r√©ussie !');
  }
};
</script>
`}/>

## Utilisation du composant SyForm

Le composant `SyForm` simplifie grandement la gestion des formulaires en centralisant la validation et en g√©rant automatiquement la soumission :

<Source dark code={`
<template>
  <SyForm ref="form" @submit="handleSubmit" :validate-on-submit="true">
    <div class="d-flex flex-column gap-4">
      <SyTextField 
        v-model="username" 
        label="Nom d'utilisateur" 
        required 
      />
      <SyTextField 
        v-model="password" 
        label="Mot de passe" 
        type="password" 
        :custom-rules="passwordRules" 
      />
      <SyTextField 
        v-model="confirmPassword" 
        label="Confirmer le mot de passe" 
        type="password" 
        :custom-rules="confirmPasswordRules" 
      />
      <VBtn type="submit" color="primary">S'inscrire</VBtn>
    </div>
  </SyForm>
</template>

<script setup>

const username = ref('');
const password = ref('');
const confirmPassword = ref('');
const form = ref();

// R√®gles r√©actives pour la validation crois√©e
const passwordRules = computed(() => [
  { type: 'minLength', options: { length: 8, message: 'Minimum 8 caract√®res' } },
  { type: 'required', options: { message: 'Le mot de passe est obligatoire' } },
]);

const confirmPasswordRules = computed(() => [
  { 
    type: 'custom', 
    options: {
      validate: value => value === password.value || 'Les mots de passe ne correspondent pas',
      message: 'Les mots de passe ne correspondent pas',
    } 
  },
  { type: 'required', options: { message: 'Veuillez confirmer le mot de passe' } },
]);

const handleSubmit = async () => {
  // SyForm g√®re automatiquement la validation avec validate-on-submit="true"
  // Cette fonction n'est appel√©e que si le formulaire est valide
  console.log('Formulaire valide, inscription en cours...');
  
  // Appel API d'inscription
  try {
    await registerUser({
      username: username.value,
      password: password.value
    });
    console.log('Inscription r√©ussie !');
  } catch (error) {
    console.error('Erreur lors de l\\'inscription:', error);
  }
};

// Validation manuelle si n√©cessaire
const validateManually = async () => {
  const isValid = await form.value?.validate();
  if (isValid) {
    console.log('Formulaire valide !');
  } else {
    console.log('Formulaire invalide !');
  }
};
</script>
`}/>

### Avantages du SyForm

- **Validation automatique** : Avec `validate-on-submit="true"`, tous les champs sont valid√©s automatiquement
- **Gestion centralis√©e** : Un seul composant g√®re l'ensemble du formulaire
- **√âv√©nement @submit** : Ne se d√©clenche que si le formulaire est valide
- **M√©thode validate()** : Permet la validation manuelle via `form.value.validate()`
- **Compatibilit√©** : Fonctionne avec tous les composants du design system

### Formulaire mixte avec SyForm

`SyForm` peut g√©rer diff√©rents types de composants dans un m√™me formulaire :

<Source dark code={`
<template>
  <SyForm ref="form" @submit="handleSubmit">
    <div class="d-flex flex-column gap-4">
      <SyTextField 
        v-model="formData.name" 
        label="Nom complet" 
        required 
      />
      <SyTextField 
        v-model="formData.email" 
        label="Email" 
        :custom-rules="emailRules" 
      />
      <SySelect 
        v-model="formData.country" 
        :items="countries" 
        label="Pays" 
        required 
      />
      <DatePicker 
        v-model="formData.birthDate" 
        label="Date de naissance" 
        :custom-rules="birthDateRules" 
      />
      <VBtn type="submit" color="primary">Enregistrer</VBtn>
    </div>
  </SyForm>
</template>

<script setup>

const form = ref();
const formData = ref({
  name: '',
  email: '',
  country: '',
  birthDate: null
});

const countries = [
  { text: 'France', value: 'fr' },
  { text: 'Allemagne', value: 'de' },
  { text: 'Espagne', value: 'es' },
  { text: 'Italie', value: 'it' },
];

const emailRules = [
  { type: 'email', options: { message: "L'email n'est pas valide" } },
  { type: 'required', options: { message: "L'email est obligatoire" } },
];

const birthDateRules = [
  { type: 'notAfterToday', options: { message: 'La date de naissance ne peut pas √™tre dans le futur' } },
  { type: 'required', options: { message: 'La date de naissance est obligatoire' } },
];

const handleSubmit = async () => {
  console.log('Donn√©es du formulaire:', formData.value);
  // Traitement des donn√©es...
};
</script>
`}/>

## Cr√©er un composant compatible avec SyForm

Pour cr√©er vos propres composants qui s'int√®grent automatiquement avec SyForm, utilisez le composable `useValidatable` :

### Composant personnalis√© basique

<Source dark code={`
<template>
  <div class="custom-input">
    <label>{{ label }}</label>
    <input 
      v-model="inputValue" 
      :class="{ 'error': hasError }"
      @blur="validate"
    />
    <div v-if="hasError" class="error-messages">
      <p v-for="error in errors" :key="error">{{ error }}</p>
    </div>
  </div>
</template>

<script setup lang='ts'>
import { useValidation } from '@cnamts/synapse'
import { computed, ref } from 'vue';

const props = defineProps({
  modelValue: String,
  label: String,
  customRules: { type: Array, default: () => [] },
  required: Boolean
});

const emit = defineEmits(['update:modelValue']);

// Gestion de la valeur
const inputValue = computed({
  get: () => props.modelValue,
  set: (value) => emit('update:modelValue', value)
});

// Validation
const { validateField, hasError, errors, clearValidation } = useValidation({
  fieldIdentifier: props.label
});

// Construire les r√®gles
const rules = computed(() => {
  const allRules = [...props.customRules];
  if (props.required) {
    allRules.push({ type: 'required', options: { message: \`\${props.label} est obligatoire\` } });
  }
  return allRules;
});

// M√©thode de validation pour SyForm
const validateOnSubmit = () => {
  const result = validateField(inputValue.value, rules.value);
  return !result.hasError;
};

// S'enregistrer aupr√®s de SyForm
useValidatable(validateOnSubmit);

// Validation en temps r√©el
const validate = () => {
  validateField(inputValue.value, rules.value);
};

// Exposer la m√©thode pour validation manuelle
defineExpose({
  validateOnSubmit,
  clearValidation
});
</script>
`}/>

### üîë Points cl√©s pour l'int√©gration SyForm

- **`useValidatable(validateOnSubmit)`** : Enregistre automatiquement le composant aupr√®s de SyForm
- **`validateOnSubmit()`** : M√©thode obligatoire qui retourne `true` si valide, `false` sinon
- **`defineExpose()`** : Expose les m√©thodes pour la validation manuelle si n√©cessaire
- **Auto-enregistrement** : Le composant s'enregistre automatiquement au `onMounted` et se d√©senregistre au `onBeforeUnmount`

### Composant avanc√© avec validation personnalis√©e

<Source dark code={`
<template>
  <div class="rating-input">
    <label>{{ label }}</label>
    <div class="stars">
      <button 
        v-for="star in 5" 
        :key="star"
        @click="setRating(star)"
        :class="{ active: star <= currentRating }"
      >
        ‚≠ê
      </button>
    </div>
    <div v-if="hasError" class="error-messages">
      <p v-for="error in errors" :key="error">{{ error }}</p>
    </div>
    <div v-if="hasSuccess" class="success-messages">
      <p v-for="success in successes" :key="success">{{ success }}</p>
    </div>
  </div>
</template>

<script setup>
import { ref, computed } from 'vue'
import { useValidation } from '@/composables/validation/useValidation';
import { useValidatable } from '@/composables/validation/useValidatable';

const props = defineProps({
  modelValue: Number,
  label: String,
  minRating: { type: Number, default: 1 },
  required: { type: Boolean, default: false }
});

const emit = defineEmits(['update:modelValue']);

const currentRating = computed({
  get: () => props.modelValue || 0,
  set: (value) => emit('update:modelValue', value)
});

// Validation avec r√®gles personnalis√©es
const { validateField, hasError, hasSuccess, errors, successes } = useValidation({
  fieldIdentifier: props.label,
  showSuccessMessages: true
});

const setRating = (rating) => {
  currentRating.value = rating;
  validate();
};

// R√®gles de validation personnalis√©es
const rules = computed(() => {
  const allRules = [];
  
  if (props.required) {
    allRules.push({
      type: 'custom',
      options: {
        validate: (value) => value > 0 || \`\${props.label} est obligatoire\`,
        successMessage: 'Merci pour votre √©valuation !'
      }
    });
  }
  
  if (props.minRating > 1) {
    allRules.push({
      type: 'custom',
      options: {
        validate: (value) => value >= props.minRating || \`Minimum \${props.minRating} √©toiles requis\`
      }
    });
  }
  
  return allRules;
});

const validate = () => {
  validateField(currentRating.value, rules.value);
};

// M√©thode pour SyForm
const validateOnSubmit = () => {
  const result = validateField(currentRating.value, rules.value);
  return !result.hasError;
};

// Enregistrement automatique avec SyForm
useValidatable(validateOnSubmit);

defineExpose({
  validateOnSubmit,
  validate
});
</script>
`}/>

### Utilisation dans SyForm

Une fois votre composant cr√©√©, il fonctionne automatiquement avec SyForm :

<Source dark code={`
<template>
  <SyForm @submit="handleSubmit">
    <CustomInput 
      v-model="name" 
      label="Nom" 
      required 
      :custom-rules="nameRules" 
    />
    <RatingInput 
      v-model="satisfaction" 
      label="Satisfaction" 
      :min-rating="3" 
      required 
    />
    <VBtn type="submit">Envoyer</VBtn>
  </SyForm>
</template>

<script setup>
import { ref } from 'vue'
import { useValidation } from '@/composables/validation/useValidation'
import { useValidatable } from '@/composables/validation/useValidatable'

const name = ref('');
const satisfaction = ref(0);

const nameRules = [
  { type: 'minLength', options: { length: 2, message: 'Minimum 2 caract√®res' } }
];

const handleSubmit = () => {
  // Appel√© seulement si tous les composants sont valides !
  console.log('Formulaire valide:', { name: name.value, satisfaction: satisfaction.value });
};
</script>
`}/>

## Validation sans SyForm (approche manuelle)

Dans certains cas, vous ne pouvez pas utiliser SyForm (int√©gration avec des composants tiers, formulaires complexes, etc.). Voici comment g√©rer la validation manuellement :

### Validation avec validateOnSubmit()

<Source dark code={`
<template>
  <form @submit.prevent="handleSubmit">
    <SyTextField
      ref="emailField"
      v-model="email"
      label="Email"
      :custom-rules="emailRules"
    />
    
    <SyTextField
      ref="passwordField"
      v-model="password"
      label="Mot de passe"
      type="password"
      :custom-rules="passwordRules"
    />
    
    <VBtn type="submit" :disabled="isSubmitting">
      {{ isSubmitting ? 'Connexion...' : 'Se connecter' }}
    </VBtn>
    
    <p v-if="formError" class="error-message">{{ formError }}</p>
  </form>
</template>

<script setup>
import { ref } from 'vue'
import { useValidation } from '@/composables/validation/useValidation'
import { useValidatable } from '@/composables/validation/useValidatable'

const email = ref('');
const password = ref('');
const isSubmitting = ref(false);
const formError = ref('');

// R√©f√©rences aux composants pour acc√©der √† validateOnSubmit()
const emailField = ref();
const passwordField = ref();

const emailRules = [
  { type: 'email', options: { message: "L'email n'est pas valide" } },
  { type: 'required', options: { message: "L'email est obligatoire" } }
];

const passwordRules = [
  { type: 'required', options: { message: 'Le mot de passe est obligatoire' } }
];

const handleSubmit = async () => {
  formError.value = '';
  isSubmitting.value = true;
  
  try {
    // Validation manuelle de tous les champs
    const isEmailValid = await emailField.value?.validateOnSubmit();
    const isPasswordValid = await passwordField.value?.validateOnSubmit();
    
    if (isEmailValid && isPasswordValid) {
      // Tous les champs sont valides, on peut soumettre
      console.log('Formulaire valide, connexion en cours...');
      
      // Appel API de connexion
      await loginUser(email.value, password.value);
      console.log('Connexion r√©ussie !');
    } else {
      formError.value = 'Veuillez corriger les erreurs dans le formulaire';
    }
  } catch (error) {
    formError.value = 'Erreur lors de la connexion';
    console.error('Erreur:', error);
  } finally {
    isSubmitting.value = false;
  }
};
</script>
`}/>

### üîë Points cl√©s de l'approche manuelle

- **`ref` sur chaque champ** : N√©cessaire pour acc√©der √† `validateOnSubmit()`
- **Validation explicite** : Vous devez appeler `validateOnSubmit()` sur chaque champ
- **Gestion des erreurs** : V√©rifiez le retour de chaque validation
- **√âtat de soumission** : G√©rez manuellement l'√©tat `isSubmitting`

### Validation crois√©e manuelle

Pour la validation crois√©e sans SyForm, utilisez des `ref` et `watch` :

<Source dark code={`
<template>
  <form @submit.prevent="handleSubmit">
    <SyTextField
      ref="passwordField"
      v-model="password"
      label="Mot de passe"
      type="password"
      :custom-rules="passwordRules"
    />
    
    <SyTextField
      ref="confirmPasswordField"
      v-model="confirmPassword"
      label="Confirmer le mot de passe"
      type="password"
      :custom-rules="confirmPasswordRules"
    />
    
    <VBtn type="submit">S'inscrire</VBtn>
  </form>
</template>

<script setup>
import { ref } from 'vue'
import { useValidation } from '@/composables/validation/useValidation'
import { useValidatable } from '@/composables/validation/useValidatable'

const password = ref('');
const confirmPassword = ref('');

const passwordField = ref();
const confirmPasswordField = ref();

const passwordRules = [
  { type: 'minLength', options: { length: 8, message: 'Minimum 8 caract√®res' } },
  { type: 'required', options: { message: 'Le mot de passe est obligatoire' } }
];

const confirmPasswordRules = [
  {
    type: 'custom',
    options: {
      validate: (value) => {
        if (value !== password.value) {
          return 'Les mots de passe ne correspondent pas';
        }
        return true;
      }
    }
  },
  { type: 'required', options: { message: 'Veuillez confirmer le mot de passe' } }
];

// Revalider la confirmation quand le mot de passe change
watch(password, () => {
  if (confirmPassword.value && confirmPasswordField.value) {
    // Forcer la revalidation du champ de confirmation
    confirmPasswordField.value.validateOnSubmit();
  }
});

const handleSubmit = async () => {
  const isPasswordValid = await passwordField.value?.validateOnSubmit();
  const isConfirmValid = await confirmPasswordField.value?.validateOnSubmit();
  
  if (isPasswordValid && isConfirmValid) {
    console.log('Inscription r√©ussie !');
  }
};
</script>
`}/>

### ‚ö†Ô∏è Limitations de l'approche manuelle

- **Plus de code** : Gestion explicite de chaque champ
- **Risque d'oubli** : Facile d'oublier de valider un champ
- **Maintenance** : Plus complexe √† maintenir
- **R√©activit√©** : N√©cessite des `watch()` pour la validation crois√©e

> **üí° Recommandation** : Utilisez SyForm quand c'est possible, l'approche manuelle seulement pour les cas sp√©cifiques.

## Composants avec validation int√©gr√©e

Plusieurs composants du Design System int√®grent d√©j√† la validation :

- **SyForm** : Conteneur de formulaire avec validation automatique
- **SyTextField** : Pour les champs texte
- **SySelect** : Pour les listes d√©roulantes
- **NirField** : Pour les num√©ros de s√©curit√© sociale
- **DatePicker** : Pour les dates
- **PeriodField** : Pour les p√©riodes (deux dates li√©es)
- **PasswordField** : Pour les mots de passe s√©curis√©s

### Exemple avec NirField

<Source dark code={`
<template>
  <form @submit.prevent="handleSubmit">
    <NirField
      ref="nirFieldRef"
      v-model="nirValue"
      label="Num√©ro de s√©curit√© sociale"
    />
    
    <SyButton type="submit">Valider</SyButton>
  </form>
</template>

<script setup>
import { NirField, SyButton } from '@cnamts/synapse';
import { ref, computed, watch } from 'vue';
import { useValidation } from '@/composables/validation/useValidation';
import { useValidatable } from '@/composables/validation/useValidatable';
import { ref, computed } from 'vue';
import { useValidation } from '@/composables/validation/useValidation';
import { useValidatable } from '@/composables/validation/useValidatable';

const nirValue = ref('');
const nirFieldRef = ref();

const handleSubmit = async () => {
  const isValid = await nirFieldRef.value.validateOnSubmit();
  
  if (isValid) {
    console.log('NIR valide :', nirValue.value);
  }
};
</script>
`}/>

## R√®gles de validation disponibles

### R√®gles g√©n√©riques
- `required` : Champ obligatoire
- `minLength` / `maxLength` : Longueur minimale/maximale
- `min` / `max` : Valeur minimale/maximale pour les nombres
- `email` : Format d'email valide
- `matchPattern` : Correspondance √† une expression r√©guli√®re

### R√®gles de dates
- `notBeforeToday` / `notAfterToday` : Date apr√®s/avant aujourd'hui
- `notBeforeDate` / `notAfterDate` : Date apr√®s/avant une date sp√©cifique
- `notWeekend` : Jour ouvrable
- `isHolidayDay` : Jour non f√©ri√©

### R√®gles personnalis√©es
Utilisez le type `custom` avec une fonction `validate` pour cr√©er vos propres r√®gles :

<Source dark code={`
const customRule = {
  type: 'custom',
  options: {
    validate: (value) => {
      // Votre logique personnalis√©e
      if (!condition) {
        return 'Message d\'erreur personnalis√©';
      }
      return true; // Valide
    },
    // Optionnel : traiter comme avertissement au lieu d'erreur
    isWarning: false
  }
};
`}/>

## Bonnes pratiques

1. **Utilisez SyForm** : Privil√©giez le composant `SyForm` pour une gestion centralis√©e et automatique de la validation
2. **R√®gles r√©actives** : Utilisez `computed()` pour les r√®gles qui d√©pendent d'autres valeurs (validation crois√©e)
3. **Validation progressive** : Validez pendant la saisie pour une r√©troaction imm√©diate
4. **Messages clairs** : Utilisez des messages d'erreur explicites et constructifs
5. **Validation c√¥t√© client ET serveur** : Ne vous fiez jamais uniquement √† la validation c√¥t√© client
6. **Utilisez validateOnSubmit** : Assurez-vous que tous les champs sont valid√©s √† la soumission
7. **Ordre des r√®gles crucial** : Mettez toujours `required` **en dernier** ! L'ordre d√©termine quel message s'affiche en premier
8. **Utilisez les avertissements** pour les recommandations non-bloquantes
9. **C√©l√©brez la r√©ussite** avec des messages de succ√®s pour renforcer les bonnes pratiques

## Conclusion

Le syst√®me de validation du Design System vous permet de cr√©er des formulaires intuitifs avec des retours utilisateur riches. En combinant validation √† la saisie et validation √† la soumission, vous offrez une exp√©rience utilisateur optimale tout en garantissant l'int√©grit√© des donn√©es.
